name: Test Broken Trust (Should FAIL)

on:
  pull_request:
    branches: [ main ]
    paths:
      - 'k8s/scripts/break-app-b-trust.sh'
      - 'k8s/scripts/upload-bad-trust-to-vault.sh'
  workflow_dispatch:

jobs:
  test-broken-trust:
    name: Test mTLS Failure with Invalid Truststore
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: 'maven'

    - name: Build Maven project
      run: mvn clean package -DskipTests -B

    - name: Set up Minikube
      uses: medyagh/setup-minikube@latest
      with:
        minikube-version: latest
        driver: docker
        cpus: 2
        memory: 4096
        kubernetes-version: v1.28.0

    - name: Verify Kubernetes cluster
      run: |
        kubectl cluster-info
        kubectl get nodes -o wide

    - name: Make scripts executable
      run: chmod +x k8s/scripts/*.sh

    - name: Generate valid certificates first
      run: |
        cd k8s/scripts
        bash generate-certs.sh

    - name: Generate INVALID truststore for App B
      run: |
        cd k8s/scripts
        bash break-app-b-trust.sh

    - name: Build Docker images
      run: |
        docker build -t app-a:1.0.0-SNAPSHOT -f k8s/Dockerfile-app-a .
        docker build -t app-b:1.0.0-SNAPSHOT -f k8s/Dockerfile-app-b .
        echo "=== Built images on host ==="
        docker images | grep app-

    - name: Load images into Minikube
      run: |
        minikube image load app-a:1.0.0-SNAPSHOT
        minikube image load app-b:1.0.0-SNAPSHOT
        echo "=== Images in Minikube ==="
        minikube image ls | grep app-

    - name: Deploy Vault
      run: |
        kubectl apply -f k8s/manifests/vault-deployment.yaml
        kubectl apply -f k8s/manifests/vault-service.yaml
        sleep 10
        kubectl wait --for=condition=ready pod -l app=vault --timeout=180s
        echo "✓ Vault is ready"

    - name: Initialize Vault
      run: |
        cd k8s/scripts
        bash init-vault.sh

    - name: Upload certificates to Vault (App A gets VALID trust, App B gets INVALID trust)
      run: |
        cd k8s/scripts

        # First upload valid certs for App A
        bash upload-certs-to-vault.sh

        # Then overwrite App B with broken truststore
        bash upload-bad-trust-to-vault.sh

    - name: Deploy services
      run: |
        kubectl apply -f k8s/manifests/app-a-service.yaml
        kubectl apply -f k8s/manifests/app-b-service.yaml

    - name: Deploy App A
      run: |
        kubectl apply -f k8s/manifests/app-a-deployment.yaml
        kubectl patch deployment app-a -p '{"spec":{"template":{"spec":{"containers":[{"name":"app-a","imagePullPolicy":"Never"}]}}}}'

    - name: Deploy App B
      run: |
        kubectl apply -f k8s/manifests/app-b-deployment.yaml
        kubectl patch deployment app-b -p '{"spec":{"template":{"spec":{"containers":[{"name":"app-b","imagePullPolicy":"Never"}]}}}}'

    - name: Wait for deployments
      run: |
        echo "Waiting for deployments (up to 5 minutes)..."
        kubectl wait --for=condition=available --timeout=300s deployment/app-a
        kubectl wait --for=condition=available --timeout=300s deployment/app-b

    - name: Show App B truststore details
      run: |
        POD_B=$(kubectl get pod -l app=app-b -o jsonpath='{.items[0].metadata.name}')
        echo "=== App B Truststore Contents (Should have FAKE CA) ==="
        kubectl exec $POD_B -- keytool -list -v -keystore /etc/security/ssl/truststore.jks -storepass changeit -storetype JKS

    - name: Test App A → App B (SHOULD FAIL)
      run: |
        POD_A=$(kubectl get pod -l app=app-a -o jsonpath='{.items[0].metadata.name}')

        echo "=== Testing App A → App B (expecting FAILURE) ==="
        set +e  # Don't exit on error
        RESPONSE=$(kubectl exec $POD_A -- curl -k --cert /etc/security/ssl/app-a-keystore.p12:changeit --cert-type P12 https://app-b.default.svc.cluster.local:8443/api/greet 2>&1)
        EXIT_CODE=$?
        set -e

        echo "Exit code: $EXIT_CODE"
        echo "Response: $RESPONSE"

        # We EXPECT this to fail
        if [ $EXIT_CODE -eq 0 ]; then
          echo ""
          echo "❌ TEST FAILED: Connection succeeded when it should have FAILED"
          echo "App B has an invalid truststore but still accepted the connection!"
          echo ""
          echo "=== App B Logs ==="
          kubectl logs -l app=app-b --tail=50
          exit 1
        else
          echo ""
          echo "✅ TEST PASSED: Connection failed as expected"
          echo "This confirms App B's invalid truststore is rejecting connections"
        fi

    - name: Verify SSL/TLS error in logs
      run: |
        echo "=== Checking for SSL/TLS errors in App B logs ==="
        kubectl logs -l app=app-b --tail=100 | grep -i "ssl\|tls\|certificate\|handshake\|PKIX" || echo "No SSL errors found in logs (unexpected)"

    - name: Test App B → App A (SHOULD ALSO FAIL)
      run: |
        POD_B=$(kubectl get pod -l app=app-b -o jsonpath='{.items[0].metadata.name}')

        echo "=== Testing App B → App A (expecting FAILURE) ==="
        set +e
        RESPONSE=$(kubectl exec $POD_B -- curl -k --cert /etc/security/ssl/app-b-keystore.p12:changeit --cert-type P12 https://app-a.default.svc.cluster.local:8443/api/greet 2>&1)
        EXIT_CODE=$?
        set -e

        echo "Exit code: $EXIT_CODE"
        echo "Response: $RESPONSE"

        # We EXPECT this to fail (App B won't trust App A's cert when it responds)
        if [ $EXIT_CODE -eq 0 ]; then
          echo ""
          echo "❌ TEST FAILED: Connection succeeded when it should have FAILED"
          echo "App B has an invalid truststore but still accepted App A's certificate!"
          exit 1
        else
          echo ""
          echo "✅ TEST PASSED: Connection failed as expected"
        fi

    - name: Test RestTemplate call (SHOULD FAIL)
      run: |
        POD_A=$(kubectl get pod -l app=app-a -o jsonpath='{.items[0].metadata.name}')

        echo "=== Testing RestTemplate A → B (expecting FAILURE) ==="
        set +e
        RESPONSE=$(kubectl exec $POD_A -- curl -k --cert /etc/security/ssl/app-a-keystore.p12:changeit --cert-type P12 https://localhost:8443/api/call-app-b 2>&1)
        EXIT_CODE=$?
        set -e

        echo "Exit code: $EXIT_CODE"
        echo "Response: $RESPONSE"

        # Check if response contains error indication
        if echo "$RESPONSE" | grep -qi "error\|fail\|exception"; then
          echo ""
          echo "✅ TEST PASSED: RestTemplate call failed as expected"
        else
          echo ""
          echo "❌ TEST FAILED: RestTemplate call succeeded when it should have FAILED"
          exit 1
        fi

    - name: Show all logs on failure
      if: failure()
      run: |
        echo "=== App A Logs ==="
        kubectl logs -l app=app-a --tail=200
        echo ""
        echo "=== App B Logs ==="
        kubectl logs -l app=app-b --tail=200
        echo ""
        echo "=== Vault Logs ==="
        kubectl logs -l app=vault --tail=100

    - name: Cleanup
      if: always()
      run: |
        kubectl delete deployment app-a app-b vault --ignore-not-found=true
        kubectl delete service app-a app-b vault --ignore-not-found=true
        kubectl delete serviceaccount app-a app-b vault --ignore-not-found=true
        kubectl delete configmap vault-config --ignore-not-found=true
        kubectl delete clusterrolebinding vault-tokenreview-binding --ignore-not-found=true
        kubectl delete clusterrole vault-tokenreview --ignore-not-found=true
